# 读书笔记

##### 阅读者：hauk0101

## 简介

书名：《你不知道的JavaScript(上卷)》<br/>
作者：Kyle Simpson <br/>
译者：赵望野 梁杰 <br/>
出版发行：人民邮电出版社 <br/>
出版时间：2015年4月

## 读后感

## 总结
### 第一部分 作用域和闭包
#### 第1章 作用域是什么

* 作用域是一套规则，用于确定在何处以及如何查找变量。如果查找的目的是对变量进行赋值，那么就会使用 LHS 查询；如果目的是获取变量的值，就会使用 RHS 查询。
赋值操作会导致 LHS 查询。= 操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。

* JavaScript 引擎首先会在代码执行前对其进行编译，在这个过程中，像 `var a = 2` 这样的声明会被分解成两个独立的步骤：

    * 首先，var a 在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。
    * 接下来，a = 2 会查询（LHS 查询）变量 a 并对其进行赋值。

* LHS 和 RHS 查询都会在当前执行作用域中开始，如果有需要（也就是说没有它们没有找到所需的变量），就会向上级作用域继续查找目标变量，这样每次上升一级作用域，最后抵达全局作用域，无论找到或者没找到都将停止。
* 不成功的 RHS 引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式的创建一个全局变量（非严格模式下），该变量使用 LHS 引用的目标作为标识符，或者抛出 ReferenceError 异常（严格模式下）。

* 个人理解及注意事项：
    * 个人理解：所谓的作用域其实就是 JS 引擎在编译阶段寻找变量过程中所遵守的一种规则，即如果当前作用域中没有该对象的声明，则会到上一级作用域中查找，直到全局作用域（window) 中，无论是否存该变量，都会停止查找。
    * 注意事项：
        * LHS 和 RHS 是本质是 JS 引擎在查找变量时的两种类型，LHS 可以理解为赋值相关的查找，RHS 可以理解为获取变量的值相关的查找。
        * LHS 和 RHS 的关系：
            * 相同点：两者都可以从当前作用域依次向上查找，知道全局作用域停止。
            * 不同点：
                * RHS 如果没有找到所有作用域中对应变量的存在，则会抛出 ReferenceError 异常，也就是我们常见的 a is not define;
                * 在非严格模式下，LHS 如果没有找到所有作用域中对应变量的存在，则会自动隐式的创建一个全局变量；
                * 在严格模式下，如果在所有的作用域中对应的变量都不存在，则 RHS 和 LHS 都会抛出 ReferenceError 异常，也就是我们常见的 a is not define。

#### 第2章 词法作用域

* 词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它们进行查找。

* JavaScript 中有两个机制可以“欺骗”词法作用域： eval(...) 和 width 。前者可以对一段包含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域（在运行时）。后者本质上是通过将一个对象的引用当做作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域（同样是在运行时）。

* 这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认为这样的优化是无效的。使用这其中任何一个机制都将导致代码运行变慢。不要使用它们。

#### 第3章 函数作用域和块作用域

* 函数是 JavaScript 中最常见的作用域单元。本质上，声明在一个函数内部的变量或函数会在所处的作用域中“隐藏”起来，这是有意为之的良好软件的设计原则。

* 但函数不是唯一的作用域单元。块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块（通常指{ .. }内部）。

* 从ES3开始，try / catch 结构在 catch 分句中具有块作用域。

* 在ES6中引入了 let 关键字（var关键字的表亲），用来在任意代码块中声明变量。if(..){ let a = 2;} 会声明一个劫持了 if 的 {..} 块的变量，并且将变量添加到这个块中。

* 有些人认为块级作用域不应该完全作为函数作用域的替代方案。两种功能应该同时存在，开发者可以并且也应该根据需要选择使用何种作用域，创造可读、可维护的优良代码。

* 匿名函数的缺点
    * 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。
    * 如果没有函数名，当函数需要引用自身时只能使用已经过期的 arguments.callee引用。比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。
    * 匿名函数省略了对于代码可读性/可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。

#### 第4章 提升

* 我们习惯将 var a = 2;看作一个生命，而实际上 JavaScript 引擎并不这么认为。它将 var a 和 a = 2 当作两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务。

* 这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。可以将这个过程形象地想象成所有的声明（变量和函数）都会被“移动”到各自作用域的最顶端，这个过程被称为提升。

* 声明本身会被提升，而包括函数表达式的赋值在内的复制操作并不会提升。

* 要注意避免重复声明，特别是当普通的 var 声明和函数声明混合在一起的时候，否则会引起很多危险的问题！

* 函数声明会被提升，但函数表达式不会被提升。即使是具名的函数表达式页不会被提升。

* 当函数声明和变量声明同时存在时，如果发生重复，则函数声明优先被提升。

#### 第5章 作用域闭包

* 当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这是就产生了闭包。

* 闭包实现模块：
    * 为创建内部作用域而调用了一个包装函数；
    * 包装函数的返回值必须包括一个队内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。

* 个人理解：当理解闭包时，一定要想到词法作用域，所谓词法作用域就是在书写代码时，变量所在位置（即被浏览器编译识别的变量位置），闭包即在作用域外部使用函数时，能够让该函数依然调用其词法作用域中的相关变量的现象。